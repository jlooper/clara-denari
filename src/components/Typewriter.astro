---
export interface Props {
  text: string;
  speed?: number;
  delay?: number;
  class?: string;
}

const { text, speed = 50, delay = 0, class: className = "" } = Astro.props;
---

<div class={`typewriter ${className}`} data-text={text} data-speed={speed} data-delay={delay}>
  <span class="typewriter-text"></span>
  <span class="typewriter-cursor">|</span>
</div>

<style>
  .typewriter-cursor {
    animation: blink 1s infinite;
    color: #ffd700;
  }

  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
</style>

<script>
  interface TextItem {
    type: 'text';
    content: string;
  }

  interface BreakItem {
    type: 'break';
  }

  type ProcessedItem = TextItem | BreakItem;

  class Typewriter {
      element: any;
      textElement: any;
      text: any;
      speed: number;
      delay: number;
      currentIndex: number;
      processedText: ProcessedItem[];
      currentTextNode: any;
      
    constructor(element) {
      this.element = element;
      this.textElement = element.querySelector('.typewriter-text');
      this.text = element.dataset.text;
      this.speed = parseInt(element.dataset.speed) || 50;
      this.delay = parseInt(element.dataset.delay) || 0;
      this.currentIndex = 0;
      this.processedText = this.parseTextWithBreaks(this.text);
      this.currentTextNode = null;
      
      this.init();
    }

    parseTextWithBreaks(text: string): ProcessedItem[] {
      // Split text by <br/> tags and convert them to actual line breaks
      const parts = text.split(/<br\s*\/?>/i);
      const processed: ProcessedItem[] = [];
      
      for (let i = 0; i < parts.length; i++) {
        if (i > 0) {
          // Add a line break element
          processed.push({ type: 'break' });
        }
        // Add the text part
        processed.push({ type: 'text', content: parts[i] });
      }
      
      return processed;
    }

    init() {
      setTimeout(() => {
        this.type();
      }, this.delay);
    }

    type() {
      if (this.currentIndex < this.processedText.length) {
        const currentItem = this.processedText[this.currentIndex];
        
        if (currentItem.type === 'break') {
          // Create a line break
          const br = document.createElement('br');
          this.textElement.appendChild(br);
          this.currentIndex++;
          setTimeout(() => this.type(), this.speed);
        } else if (currentItem.type === 'text') {
          // Create a new text node for this text segment
          this.currentTextNode = document.createTextNode('');
          this.textElement.appendChild(this.currentTextNode);
          // Type out the text character by character
          this.typeText(currentItem.content, 0);
        }
      }
    }

    typeText(text: string, charIndex: number) {
      if (charIndex < text.length) {
        this.currentTextNode.textContent += text.charAt(charIndex);
        setTimeout(() => this.typeText(text, charIndex + 1), this.speed);
      } else {
        // Text part is complete, move to next item
        this.currentIndex++;
        setTimeout(() => this.type(), this.speed);
      }
    }
  }

  // Initialize typewriter effects when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    const typewriterElements = document.querySelectorAll('.typewriter');
    typewriterElements.forEach(element => {
      new Typewriter(element);
    });
  });
</script> 