---
export interface Props {
  text?: string;
  translationKey?: string;
  speed?: number;
  delay?: number;
  class?: string;
}

const { text, translationKey, speed = 50, delay = 0, class: className = "" } = Astro.props;
---

<div class={`typewriter ${className}`} data-text={text || ''} data-translation-key={translationKey || ''} data-speed={speed} data-delay={delay}>
  <span class="typewriter-text"></span>
  <span class="typewriter-cursor">|</span>
</div>

<style>
  .typewriter-cursor {
    animation: blink 1s infinite;
    color: #6b7280;
  }

  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
</style>

<script>
  // Import translations for global access
  import { translations } from '../i18n/translations.js';
  
  // Make translations available globally
  if (typeof window !== 'undefined') {
    (window as any).translations = translations;
  }

  interface TextItem {
    type: 'text';
    content: string;
  }

  interface BreakItem {
    type: 'break';
  }

  type ProcessedItem = TextItem | BreakItem;

  class Typewriter {
      element: any;
      textElement: any;
      text: string;
      translationKey: string;
      speed: number;
      delay: number;
      currentIndex: number;
      processedText: ProcessedItem[];
      currentTextNode: any;
      
    constructor(element) {
      this.element = element;
      this.textElement = element.querySelector('.typewriter-text');
      this.translationKey = element.dataset.translationKey || '';
      this.text = element.dataset.text || '';
      this.speed = parseInt(element.dataset.speed) || 50;
      this.delay = parseInt(element.dataset.delay) || 0;
      this.currentIndex = 0;
      this.processedText = [];
      this.currentTextNode = null;
      
      this.init();
    }

    getTranslatedText(): string {
      if (this.translationKey) {
        // Get translation from i18n system
        if (typeof window !== 'undefined' && (window as any).i18n) {
          return (window as any).i18n.t(this.translationKey);
        }
        // Fallback: try to get from localStorage or use default
        const currentLang = localStorage.getItem('preferred-language') || 'en';
        const translations = (window as any).translations || {};
        const translation = translations[this.translationKey];
        if (translation && translation[currentLang]) {
          return translation[currentLang];
        }
        // Final fallback to English
        if (translation && translation['en']) {
          return translation['en'];
        }
      }
      return this.text;
    }

    parseTextWithBreaks(text: string): ProcessedItem[] {
      // Split text by <br/> tags and convert them to actual line breaks
      const parts = text.split(/<br\s*\/?>/i);
      const processed: ProcessedItem[] = [];
      
      for (let i = 0; i < parts.length; i++) {
        if (i > 0) {
          // Add a line break element
          processed.push({ type: 'break' });
        }
        // Add the text part
        processed.push({ type: 'text', content: parts[i] });
      }
      
      return processed;
    }

    init() {
      // Get the translated text and parse it
      const translatedText = this.getTranslatedText();
      this.processedText = this.parseTextWithBreaks(translatedText);
      
      setTimeout(() => {
        this.type();
      }, this.delay);
    }

    type() {
      if (this.currentIndex < this.processedText.length) {
        const currentItem = this.processedText[this.currentIndex];
        
        if (currentItem.type === 'break') {
          // Create a line break
          const br = document.createElement('br');
          this.textElement.appendChild(br);
          this.currentIndex++;
          setTimeout(() => this.type(), this.speed);
        } else if (currentItem.type === 'text') {
          // Create a new text node for this text segment
          this.currentTextNode = document.createTextNode('');
          this.textElement.appendChild(this.currentTextNode);
          // Type out the text character by character
          this.typeText(currentItem.content, 0);
        }
      }
    }

    typeText(text: string, charIndex: number) {
      if (charIndex < text.length) {
        this.currentTextNode.textContent += text.charAt(charIndex);
        setTimeout(() => this.typeText(text, charIndex + 1), this.speed);
      } else {
        // Text part is complete, move to next item
        this.currentIndex++;
        setTimeout(() => this.type(), this.speed);
      }
    }
  }

  // Initialize typewriter effects when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    const typewriterElements = document.querySelectorAll('.typewriter');
    typewriterElements.forEach(element => {
      const typewriter = new Typewriter(element);
      // Store reference on element for language change updates
      (element as any).__typewriter = typewriter;
    });
  });

  // Listen for language changes and update typewriter text
  document.addEventListener('language-changed', () => {
    const typewriterElements = document.querySelectorAll('.typewriter');
    typewriterElements.forEach(element => {
      const typewriter = (element as any).__typewriter;
      if (typewriter && typewriter.translationKey) {
        // Clear current text
        const textElement = element.querySelector('.typewriter-text');
        if (textElement) {
          textElement.innerHTML = '';
        }
        
        // Reset and restart with new translation
        typewriter.currentIndex = 0;
        typewriter.currentTextNode = null;
        const translatedText = typewriter.getTranslatedText();
        typewriter.processedText = typewriter.parseTextWithBreaks(translatedText);
        typewriter.init();
      }
    });
  });
</script> 